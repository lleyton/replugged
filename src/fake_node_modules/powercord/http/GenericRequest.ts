/**
 * Forked from DevYukine's http module and Snekfetch
 */

import { encode } from 'querystring';
import { rootCertificates } from 'tls';
import https from 'https';
import http, { IncomingHttpHeaders } from 'http';
import { readFileSync } from 'fs';
import { parse } from 'url';
import { REPO_URL } from '../constants';
import { join } from 'path';
import dstRootPath from './dst_root_ca_x3.pem';

const dstRoot = readFileSync(join(__dirname, dstRootPath), { encoding: 'utf8' }).trim();

// // Exclude DST Root CA x3 from trust chain
const certificates = rootCertificates.filter((c) => c !== dstRoot);

/**
 * @typedef HTTPResponse
 * @property {String} raw
 * @property {Object|String} body
 * @property {Boolean} ok
 * @property {Number} statusCode
 * @property {String} statusText
 * @property {object} headers
 */

type HTTPErroredResponse = {
  raw: Buffer;
  body: object | string;
  ok: false;
  statusCode?: number;
  statusText?: string;
  headers: IncomingHttpHeaders;
};

type HTTPSuccessResponse = {
  raw: Buffer;
  body: object | string;
  ok: true;
  statusCode: number;
  statusText: string;
  headers: IncomingHttpHeaders;
};

class HTTPError extends Error {
  constructor (message: string, res: HTTPErroredResponse) {
    super(message);
    Object.assign(this, res);
    this.name = this.constructor.name;
  }
}

type RequestOptions = {
  method: string;
  uri: string;
  query: Record<string, string>;
  headers: Record<string, string>;
  data?: string
}

class GenericRequest {
  opts: RequestOptions;
  _res?: Promise<HTTPSuccessResponse>

  constructor (method: string, uri: string) {
    this.opts = {
      method,
      uri,
      query: {},
      headers: {
        'User-Agent': `Replugged (https://github.com/${REPO_URL})`
      }
    };
  }

  _objectify (key: any, value: any) {
    return key instanceof Object
      ? key
      : { [key]: value };
  }

  /**
   * Appends a querystring parameter
   * @param {String} key Parameter key
   * @param {String} value Parameter value
   * @returns {GenericRequest} Self, for fluent calls
   */
  query (key: string, value: string) {
    Object.assign(this.opts.query, this._objectify(key, value));
    return this;
  }

  /**
   * Sets a header for the request
   * @param {String} key Header name
   * @param {String} value Header value
   * @returns {GenericRequest} Self, for fluent calls
   */
  set (key: string, value: string) {
    Object.assign(this.opts.headers, this._objectify(key, value));
    return this;
  }

  /**
   * Specifies the data to send (for non-GET requests), which will get serialized based on the Content-Type header
   * <b>Make sure to specify the Content-Type header before calling this</b>
   * @param {Object|String} data Data that'll be sent
   * @returns {GenericRequest} Self, for fluent calls
   */
  // eslint-disable-next-line @typescript-eslint/ban-types
  send (data: Object | string) {
    if (data instanceof Object) {
      const serialize = this.opts.headers['Content-Type'] === 'application/x-www-form-urlencoded'
        ? encode
        : JSON.stringify;

      this.opts.data = serialize(data);
    } else {
      this.opts.data = data;
    }

    return this;
  }

  /**
   * Executes the request
   * @returns {Promise<HTTPResponse>}
   */
  execute (): Promise<HTTPSuccessResponse> {
    return new Promise((resolve, reject) => {
      const opts = Object.assign({}, this.opts);
      console.debug('%c[Replugged:HTTP]', 'color: #7289da', 'Performing request to', opts.uri);
      const { request } = opts.uri.startsWith('https')
        ? https
        : http;

      if (Object.keys(opts.query)[0]) {
        opts.uri += `?${encode(opts.query)}`;
      }

      const options = Object.assign({}, opts, parse(opts.uri), { ca: certificates });

      const req = request(options, (res) => {
        const data: Uint8Array[] = [];

        res.on('data', (chunk) => {
          data.push(chunk);
        });

        res.once('error', reject);

        res.once('end', () => {
          const raw = Buffer.concat(data);

          const ok = !!(res.statusCode && res.statusCode >= 200 && res.statusCode < 400);

          if (ok) {
            resolve({
              raw,
              body: (() => {
                if (res.headers['content-type'] && (/application\/json/).test(res.headers['content-type'])) {
                  try {
                    return JSON.parse(raw.toString());
                  } catch (_) {
                    // fall through to raw
                  }
                }

                return raw;
              })(),
              ok,
              statusCode: res.statusCode!,
              statusText: res.statusMessage!,
              headers: res.headers
            });
          } else {
            reject(new HTTPError(`${res.statusCode} ${res.statusMessage}`, {
              raw,
              body: (() => {
                if (res.headers['content-type'] && (/application\/json/).test(res.headers['content-type'])) {
                  try {
                    return JSON.parse(raw.toString());
                  } catch (_) {
                    // fall through to raw
                  }
                }

                return raw;
              })(),
              ok,
              statusCode: res.statusCode,
              statusText: res.statusMessage,
              headers: res.headers
            }));
          }
        });
      });

      req.once('error', reject);

      if (this.opts.data) {
        req.write(this.opts.data);
      }

      req.end();
    });
  }

  /**
   * Executes the request and attaches success and/or error handler
   * @param {function(HTTPResponse) | null} resolver Success handler
   * @param {function(HTTPError)|null} [rejector] Error handler
   * @returns {Promise<HTTPResponse>}
   */
  then (resolver: ((r: HTTPSuccessResponse) => any) | null, rejector: ((r: HTTPError) => any) | null): Promise<HTTPSuccessResponse> {
    if (this._res) {
      return this._res.then(resolver, rejector);
    }

    return (
      this._res = this.execute().then(resolver, rejector)
    );
  }

  /**
   * Executes the requests and attaches an error handler
   * @param {function(HTTPError)|null} [rejector] Error handler
   * @returns {Promise<HTTPResponse>}
   */
  catch (rejector: ((e: HTTPError) => any) | null): Promise<HTTPSuccessResponse> {
    return this.then(null, rejector);
  }
}

export default GenericRequest;
